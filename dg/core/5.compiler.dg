import '/importlib'
import '/itertools'
import '/posixpath'
import '/collections'

_PY_FEATURE_UNIFIED_MAKE_FUNCTION = (PY_VERSION >= 0x030600a3)
_PY_FEATURE_UNIFIED_CALL_FUNCTION = (PY_VERSION >= 0x030600b0 and PY_TAG.startswith 'cpython-')
_PY_FEATURE_NATIVE_VARARG_PACK    = (PY_VERSION >= 0x030500a4)
_PY_FEATURE_ASYNC                 = (PY_VERSION >= 0x030500a4)
_PY_FEATURE_SYNC_AITER            = (PY_VERSION >= 0x03070000) # not sure about the build

inf = float 'inf'


#: Compile some source code.
#:
#: compile :: str (Optional str) -> types.CodeType
#:
compile = data filename: '<string>' globals: () -> compileast (parse data filename) globals


#: Compile the contents of a file-like object.
#:
#: compilefd :: TextIOBase (Optional str) (Optional (iter str)) -> types.CodeType
#:
compilefd = fd filename: '<stream>' globals: () -> compileast (parsefd fd filename) globals


#: Compile an AST into Python bytecode.
#:
#: compileast :: Node (Optional (iter str)) -> types.CodeType
#:
compileast = x globals: () ->
  @ = Compiler ''
  @globals = set globals | set (@symbols x)
  @pushast x
  @return_top
  @frozen


#: Raise a `SyntaxError` regardless of arguments.
#:
#: undefined :: str -> Handler
#:
#:   where Handler = Compiler Node [Node] -> a
#:      -- a compiler-defined function. First argument is function name,
#:         second argument is the list of arguments.
#:
undefined = x -> f args ~> raise f.invalid x


#: Enforce argument count limits on a compile-time function.
#:
#: fix :: int int Handler -> Handler
#:
fix = min max h -> f args ~>
  len args < min => raise f.invalid $ 'got {} arguments, min. {}'.format (len args) min
  len args > max => raise f.invalid $ 'got {} arguments, max. {}'.format (len args) max
  h self f args


#: Push all arguments, apply a single instruction, pass the number of items as the argument.
#:
#: apply_one :: str -> Handler
#:
apply_one = x -> f xs ~>
  @pushast *: xs
  @append x (len xs) $ 1 - len xs


#: After evaluating bytecode, store the result in the variable referenced by the first argument.
#:
#: inplace :: Handler -> Handler
#:
inplace = h -> f xs ~>
  h self f xs
  @append 'DUP_TOP' delta: +1
  @popast $ head xs


#: Accept 1+ arguments, but make `f a b c ...` same as `f (a b c ...)`.
#:
#: autocall :: Handler -> Handler
#:
autocall = h -> fix 1 inf $ f xs ~> h self f $ if
  len xs > 1 => [Expression f.loc *: xs]
  otherwise  => xs


#: Infix bind handler: turn `x R` or `R x` into `x R None`.
#:
#: default_to_none :: Handler
#:
default_to_none = f [x] ~> @pushcall f x $ Constant f.loc None


#: Given two (or more) arguments, pick the first that matches a jump condition.
#:
#: shortcircuit :: str bool -> Handler
#:
shortcircuit = x -> fix 2 inf $ f [a, *bs] ~>
  @pushcond a
  for b in bs => with @jump x False -1 => @pushast b


#: Turn a handler that accepts pairs of nodes into one that accepts `u => v` nodes.
#:
#: pair_args :: (Compiler Node [(Node, Node)] -> a) -> Handler
#:
pair_args = h -> f xs ~>
  pairs = getattr f '_arrpairs' None
  pairs is None =>
    # In `if` and `except` the whole first line is clamped into a single argument,
    # so `if (1 => 2) (3 => 4)` is the same thing as `if ((1 => 2) (3 => 4))`.
    # We'll treat these as separate arguments for a shorthand notation.
    if len xs == 1 and head xs :: Expression and (head xs).op == '' => xs = (head xs).args
    # This decorator needs to be applied to both the emitter function
    # AND the symbol scanner, so we'll cache the result.
    pairs = f._arrpairs = list
      where for x in xs => yield if
        x :: RightBind  and x.op == '=>' => raise x.invalid 'no `u` in `u => v`'
        x :: LeftBind   and x.op == '=>' => x.args + [Constant x.loc None]
        x :: Expression and x.op == '=>' => x.args
        otherwise => raise x.invalid 'expected `u => v`'
  h self f f._arrpairs


#: Given two arguments, return the result of comparing them with a suitable
#: function. Note that the function name must be in `opcode.cmp_op`.
#:
#: compare :: Handler
#:
compare = fix 2 2 $ f [a, b] ~>
  chain = []
  # `a R x1 Q x2 ... xn P b` where `R`, `Q`, and so on are comparison operators
  # is a single chain that is equivalent to `a R x1 and ... and xn P b`.
  while a :: Expression and not a.closed and @getinternal a.op.value is compare =>
    # `chain` should become `[(R, x1), (Q, x2), ...]`.
    chain.insert 0 (a.op, snd (a, _ = a.args))

  @pushast a
  jumps = []
  for (op, arg) in chain =>
    # Assume the value on top of the stack is what to compare to.
    # (Let's call that value `prev`.)
    @pushast arg
    @append  'DUP_TOP'    delta: +1  #=> prev, arg, arg
    @append  'ROT_THREE'  delta: +0  #=> arg, prev, arg
    @append  'COMPARE_OP' delta: -1 $ opcode.cmp_op.index op.value  #=> arg, bool
    jumps.append $ @jump 'POP_JUMP_IF_FALSE' delta: -1  #=> arg
  @pushast b
  @append 'COMPARE_OP' delta: -1 $ opcode.cmp_op.index f.value
  # If all comparisons returned `True`, we're done and there's `True` on top
  # of the stack. If comparison with `b` returned `False`, there's `False`
  # and nothing else. But if one of the other comparisons returned `False`,
  # we've got an object that is not needed anymore.
  if jumps => with @jump 'JUMP_FORWARD' =>
    for j in jumps => j.set
    @append 'POP_TOP' delta: -1
    @pushconst False


#: Parse function definition arguments. They look like this:
#:
#:   positional (positional, pattern): default *: varargs keyword_only **: varkwargs
#:
#: parse_defn_args :: Node -> ([str], [str], [Node], {str: Node}, [str], [str], {str: Node})
#:
parse_defn_args = xs -> a, kw, da, dkw, va, vkw, add where
  a    = []  # positional
  kw   = []  # keyword-only
  da   = []  # default values
  dkw  = {}  # default values for keyword-only arguments
  va   = []  # varargs (a singleton)
  vkw  = []  # varkwargs (a singleton)
  add  = {}  # (name -> pattern) mapping

  pattern = x index -> if
    not $ x :: Name =>
      name = 'pattern:' + str index
      add !! name = x
      name
    x == '_'         => 'ignore:' + str index
    # If there are duplicate argument names, CPython will overwrite some locals,
    # and that's bad. We don't check `vkw` because it should always be the
    # last item, though.
    x in a + kw + va => raise x.invalid 'duplicate argument name'
    otherwise        => x.value

  # Consider `x -> x`. Here `x` is a single argument, thus a single `Node`.
  # Now consider `x y -> x`. Here `x y` is, technically, a function call?..
  data = if xs :: Expression and not xs.closed and xs.op == '' => xs.args
            otherwise => [xs,]

  for (i, x) in enumerate data => if
    # Variadic keyword is pretty much a catch-all argument,
    # so it doesn't make sense to have anything after it.
    vkw => raise x.invalid 'all arguments should come before `**: varkwargs`'
    # `k: v` -- argument named `k` with default value `v`
    x :: Expression and not x.closed and x.op == ':' => if
      x :: LeftBind  => raise x.invalid 'default value missing'
      x :: RightBind => raise x.invalid 'argument name missing'
      fst x.args == '*' =>
        # `*: x` -- function is variadic with argument list `x`.
        va => raise x.invalid 'can only have one `*: x`'
        va.append $ snd x.args `pattern` i
      fst x.args == '**' =>
        # `**: x` -- function is keyword-variadic with keyword mapping `x`.
        vkw.append $ snd x.args `pattern` i
      va =>
        # Doesn't make sense to have any positional arguments after `*: varargs`,
        # either. Anything after it becomes a keyword-only argument.
        k, v = x.args
        k :: Name or raise k.invalid 'keyword-only arguments cannot be patterns'
        # So what's a keyword argument? When calling a function, you can
        # pass arguments by position (e.g. `f 1 2 3`) or by name
        # (e.g. `f c: 3 a: 1 b: 2`). If a function is variadic, at some point
        # the positional arguments start being added to the list. Any argument
        # defined after `*: something` can therefore only be passed by name.
        kw.append (name = k `pattern` i)
        dkw !! name = v
      otherwise =>
        a.append  $ fst x.args `pattern` i
        da.append $ snd x.args
    x == '**' => raise x.invalid 'to ignore variadic kwargs use `**: _`'
    x == '*'  =>
      va => raise x.invalid 'can only have one `*`'
      # `*` without a name separates positional arguments from keyword-only
      # arguments without making the function variadic.
      va.append None
    va =>
      # And, unfortunately, you can't call a function like `f (some, pattern): value`.
      # So a keyword-only pattern would be unusable.
      x :: Name or raise x.invalid 'keyword-only arguments cannot be patterns'
      # Still have to call `pattern` to ensure uniqueness, though.
      kw.append $ x `pattern` i
    # In CPython, it's impossible to have an argument without a default value
    # follow an argument without one, because default values are stored
    # as a tuple.
    da => raise x.invalid 'this argument must have a default value'
    otherwise => a.append $ x `pattern` i
  # And we hit the limitations of 2-byte opargs. Great.
  len a  > 255 => raise xs.invalid 'too many positional arguments'
  len kw > 255 => raise xs.invalid 'too many keyword arguments'
  va == [None] => va = []


Compiler = subclass CodeType where
  __init__ = *: args **: kwargs ~>
    @@__init__ *: args **: kwargs
    #: Jumps to the beginnings of loops we're currently in. Used by `continue`. `None` is a sentinel.
    @loops = list' None
    #: Variables used to store exceptions. These may cause reference loops.
    @unsafe = set!
    #: The docstring to attach to the next function.
    @docstr = None
    #: Just a counter. Used an incremented by `pushmacro`.
    @counter = 0
    None

  #: Make the closure return the value from the top of the stack.
  #:
  #: return_top :: a
  #:
  return_top = ~>
    for (k, i) in @unsafe => not $ k in @cellvars =>
      # Break reference loops caused by variables which may reference this frame.
      @pushconst None
      @append 'STORE_FAST' i delta: -1
    @append 'RETURN_VALUE'

  #: Push the results of evaluating some expressions onto the stack.
  #:
  #: pushast :: Node... -> a
  #:
  pushast = *: xs ~> for x in xs =>
    x.loc => if
      @lineoff == -1 =>
        @filename = x.loc !! 0
        @lineno   = x.loc !! 1
        @lineoff  = x.loc !! 1
      otherwise =>
        # The offset starts at 0, the line number - at `co_firstlineno`.
        # To find out the next offset, read two bytes from `co_lnotab`,
        # Add the first byte to the offset, and the second byte to the line no.
        lineoff = x.loc !! 1 - @lineoff
        lineoff > 0 =>
          # Every opcode that is in `co_code[offset:next offset]` is assumed to be
          # a part of some expression on that line.
          byteoff = codelen $ drop @byteoff @bytecode
          byteoff > 0 =>
            @lineoff = x.loc !! 1
            @byteoff = len @bytecode
            # Naturally, these being bytes, they're limited to increments of 0..255.
            # They can't go back, too, presenting some problems in `where` and
            # function calls that span multiple lines, as the traceback will always
            # point to the last line while the error is actually in the first.
            @lnotab += lineoff // 256 * b'\x00\xff' +
                       byteoff // 256 * b'\xff\x00' + bytes (byteoff % 256, lineoff % 256)

    stacksize = @currstack
    x.doc => @docstr = x.doc
    if x :: Name       => @pushname  x.value
       x :: Constant   => @pushconst x.value
       x :: LeftBind   => @pushbind  False x.op *: x.args
       x :: RightBind  => @pushbind  True  x.op *: x.args
       x :: Expression => @pushcall  x.op *: x.args
       otherwise       => raise x.invalid $ 'unknown node type {}'.format type x
    x.doc => @docstr = None
    stacksize + 1 != @currstack =>
      raise x.invalid $ 'pushed {} items onto the stack'.format $ @currstack - stacksize

  #: Push some string-object pairs. Used by keyword arguments and annotations.
  #:
  #: pushmap :: {str: Node} -> a
  #:
  pushmap = xs ~> for (k, v) in xs.items! =>
    @pushconst k
    @pushast   v

  #: Evaluate multiple expressions, discarding all results but the last.
  #:
  #: pushlast :: *Node -> a
  #:
  pushlast = *: (*xs, y) ~>
    @pushnone *: xs
    @pushast y

  #: Evaluate and discard multiple expressions.
  #:
  #: pushnone :: *Node -> a
  #:
  pushnone = *: xs ~>
    for x in xs =>
      @pushast x
      @append 'POP_TOP' delta: -1

  #: Create a function out of a code object.
  #:
  #: pushclosure :: CodeType [Node] (dict str Node) -> a
  #:
  pushclosure = code defaults kwdefaults ~>
    code.return_top
    const = code.frozen
    if
      _PY_FEATURE_UNIFIED_MAKE_FUNCTION =>
        # Python 3.6a3+ uses a new MAKE_FUNCTION opcode.
        #   1. bit 0 set: tuple of default positional parameters
        #   2. bit 1 set: map of default keyword parameters
        #   3. bit 2 set: dictionary of annotations
        #   4. bit 3 set: tuple of cells containing references to free variables
        #   5. function code
        #   6. qualified name
        flags = 0
        delta = -1
        defaults =>
            @pushast *: defaults
            @append 'BUILD_TUPLE' (len defaults) $ 1 - len defaults
            flags |= 1
            delta -= 1
        kwdefaults =>
            @pushast *: kwdefaults.values!
            @pushconst $ tuple kwdefaults
            @append 'BUILD_CONST_KEY_MAP' (len kwdefaults) (-len kwdefaults)
            flags |= 2
            delta -= 1
        const.co_freevars =>
            @pushcells const.co_freevars
            @append 'BUILD_TUPLE' (len const.co_freevars) $ 1 - len const.co_freevars
            flags |= 8
            delta -= 1
        @pushconst const
        @pushconst code.qualname
        @append 'MAKE_FUNCTION' flags delta
      otherwise =>
        # Old MAKE_CLOSURE:
        #   1..2k. names & values of default keyword parameters
        #   2k+1..2k+n. default positional parameters
        #   2k+n+1. tuple of cells containing references to free variables
        #   (annotations go here, I think?)
        #   2k+n+2. function code
        #   2k+n+3. qualified name
        @pushmap  kwdefaults
        @pushast *: defaults
        @pushcells const.co_freevars
        @append    'BUILD_TUPLE' (len const.co_freevars) $ 1 - len const.co_freevars
        @pushconst const
        @pushconst code.qualname
        @append    'MAKE_CLOSURE'
          0 + len defaults + 256 * len kwdefaults
          0 - len defaults - 2   * len kwdefaults - 2

  #: If a function is compiler-defined, return its implementation.
  #:
  #: getinternal :: str -> Maybe Handler
  #:
  getinternal = name ~>
    f = @prefix.get name None
    if not f => None
       # Since the symbol scanner has already finished, this function
       # is expected to be compile-time.
       name in @symscan => f
       # Local variables override compile-time builtins.
       name in @varnames or name in @enclosed or name in @globals => None
       otherwise => f

  #: Push the result of calling `f` with `args` onto the value stack.
  #:
  #: pushcall :: Node *Node -> a
  #:
  pushcall = f *: args ~> if
    f :: Name and (g = @getinternal f.value) => g self f args
    # Infix functions don't get fancy syntax.
    # When using infix operators, varargs and keyword arguments are disabled.
    f.infix and not f.closed =>
      @pushast  f
      @pushast *: args
      @append 'CALL_FUNCTION' (len args) (-len args)
    otherwise =>
      @pushast f
      @pushcalltop 0 args

  #: Push the result of calling a function from the top of the stack.
  #:
  #: Additional arguments may be taken from there, too.
  #:
  #: pushcalltop :: int [Node] -> a
  #:
  pushcalltop = argc argv ~>
    kw = {}
    va = []
    vkw = []

    for x in argv => if
      x :: Expression and x.op == ':' => if
        x :: LeftBind      => raise x.invalid 'keyword argument without a value'
        x :: RightBind     => raise x.invalid 'keyword argument without a name'
        fst x.args in kw   => raise x.invalid 'keyword arguments should be unique'
        fst x.args == '*'  => va.extend $ tail x.args
        fst x.args == '**' => vkw.extend $ tail x.args
        fst x.args :: Name => kw !! (fst x.args).value = snd x.args
        otherwise          => raise x.invalid 'keyword arguments cannot be patterns'
      otherwise =>
        @pushast x
        argc += 1

    argc   > 255 => raise (head argv).invalid 'too many positional arguments'
    len kw > 255 => raise (head argv).invalid 'too many keyword arguments'

    if _PY_FEATURE_UNIFIED_CALL_FUNCTION =>
      # (TODO: use this on 3.5 via BUILD_TUPLE_UNPACK and co.? There's no BUILD_CONST_KEY_MAP...)
      # New opcodes: (1) CALL_FUNCTION, (2) CALL_FUNCTION_KW, (3) CALL_FUNCTION_EX
      if not va and not vkw =>
        if kw =>
          # (2) accepts positional + keyword arguments + tuple of keyword names
          @pushast *: kw.values!
          @pushconst $ tuple kw
          return @append 'CALL_FUNCTION_KW' (argc + len kw) (-1 - argc - len kw)
        # (1) only accepts positional arguments.
        return @append 'CALL_FUNCTION' argc (0 - argc)
      # (3) accepts varargs and varkwargs.
      # To pack positional arguments, we have to transform `f x *: y z: w **: v` into
      # `f *: (x,) *: y **: {('z', w)} **: v` and then pack multiple var(kw)args:
      # `f *: (!chain (x,) y) **: (!keyword_union {('z', w)} v)`. Exactly one tuple
      # is required, so if there are only keyword arguments, we push ().
      if argc or not va =>
        @append 'BUILD_TUPLE' argc (1 - argc)
      # FIXME this loses ordering between varargs and normal args, e.g. in `f *: x y`.
      @pushast *: va
      total_va = len va + bool (argc or not va)
      if total_va > 1 =>
        @append 'BUILD_TUPLE_UNPACK' total_va delta: (1 - total_va)
      if kw =>
        # Keywords are optional -- argument to CALL_FUNCTION_EX is 0 if there are none.
        @pushast *: kw.values!
        @pushconst $ tuple kw
        @append 'BUILD_CONST_KEY_MAP' (len kw) delta: (-len kw)
      @pushast *: vkw
      if len vkw > not kw =>
        # 3.6b0 BUILD_MAP_UNPACK_WITH_CALL derives stack offset of function by itself.
        @append 'BUILD_MAP_UNPACK_WITH_CALL' (len vkw + bool kw) delta: (not kw - len vkw)
      has_kwargs = int (bool vkw or bool kw)
      return @append 'CALL_FUNCTION_EX' has_kwargs delta: (-1 - has_kwargs)

    # Only old opcodes: CALL_FUNCTION[_VAR][_KW](argc + 256 * kwargc)
    if _PY_FEATURE_NATIVE_VARARG_PACK =>
      @pushast *: va
      if len va > 1 =>
        @append 'BUILD_TUPLE_UNPACK' (len va) delta: (1 - len va)
      @pushmap kw
      @pushast *: vkw
      if len vkw > 1 =>
        # Argument is (number of entries) + 256 * (stack offset to function object).
        # XXX `len va` should be 1 here?.. Don't have CPython 3.5 to check, maybe just
        #     drop support to be safe.
        k = argc + 2 * len kw + len va + len vkw
        @append 'BUILD_MAP_UNPACK_WITH_CALL' (k * 256 + len vkw) delta: (1 - len vkw)
    if not _PY_FEATURE_NATIVE_VARARG_PACK =>
      # Too old to have BUILD_*_UNPACK, will have to emulate.
      @pushmap kw
      # XXX looks suspicious that this is ordered as (f, args, kwargs, va, vkw)
      #     while the stuff above results in (f, args, va, kwargs, vkw)...
      if len va > 1 => @pushast $ Expression (head va).loc (Name (head va).loc False '!chain') *: va
         otherwise  => @pushast *: va
      if len vkw > 1 => @pushast $ Expression (head vkw).loc (Name (head vkw).loc False '!keyword_union') *: vkw
         otherwise   => @pushast *: vkw
    @append
      'CALL_FUNCTION' + '_VAR' * bool va + '_KW' * bool vkw
      0 + argc + 256 * len kw
      0 - argc - 2   * len kw - bool va - bool vkw

  #: Default infix bind implementation.
  #:
  #: `x R` <=> `y -> x R y`
  #: `R x` <=> `y -> y R x`
  #:
  #: pushbind :: bool Name Node -> a
  #:
  pushbind = right f arg ~>
    g = @getinternal f.value
    if # Makes tno sense to use compile-time partial bindings if the function itself
       # has no compile-time definition.
       g and f.value in @infixl and not right => (@infixl !! f.value) self f [arg]
       g and f.value in @infixr and     right => (@infixr !! f.value) self f [arg]
       g and not (f.value in BUILTINS) =>
         # Note that partial binding of macros does not actually use
         # runtime functions (as `pushcall` will prefer compile-time ones.)
         # Still, this is a pretty good method of checking if
         # someone's attempting to partially bind assignment operators, etc.
         raise f.invalid 'this operator requires both arguments'
       # Default binding: `x R` -> `y -> x R y`; `R y` -> `x -> x R y`.
       otherwise =>
         c = if right     => @spawn f.value ('<L>',) ('<R>',)
                otherwise => @spawn f.value ('<R>',) ('<L>',)
         c.pushcall f (Name f.loc False '<L>') (Name f.loc False '<R>')
         @pushclosure c tuple! $ dict' $ if right     => '<R>', arg
                                            otherwise => '<L>', arg

  #: Create a function.
  #:
  #: pushfunc :: Node Node -> a
  #:
  pushfunc = async args body ~> @pushfunc' async body *: (parse_defn_args args)

  #: Create a function with known arguments.
  #:
  #: pushfunc' :: Node [str] [str] [Node] (dict str Node) [str] [str] (dict str Node) -> a
  #:
  pushfunc' = async body a kw da dkw va vkw patterns ~>
    g = @spawn '<lambda>' a kw va vkw doc: @docstr
    # Don't need to create a new scope if its boundaries are exactly the same
    # as the enclosing one's. (This does not match *all* valid invocations of
    # `where`, just the most common ones: `a where b` and `where b`.)
    body :: Expression and body.op == 'where' and len body.args <= 2 =>
      body = Expression body.loc (Name body.op.loc True '\n') *: (reversed body.args)
    g.regsyms body
    g.coroutine = async
    a and a !! 0 == 'self' =>
      # This is most likely a method, and methods can use `super`.
      # To determine which class we're looking for the superclass of,
      # `super` uses a hidden free variable named `__class__` which is initialized
      # with the class object.
      g.freevars !! '__class__'
      @cellvars  !! '__class__'
    for (_, v) in patterns.items! => for a in @symbols' v => g.varnames !! a
    for (k, v) in patterns.items! =>
      g.pushname k
      g.popast   v
    g.pushast body
    @pushclosure g da dkw

  #: Create a method (a function with an additional argument named "self".)
  #:
  #: pushmethod :: Node Node -> a
  #:
  pushmethod = async args body ~>
    a, *xs = parse_defn_args args
    a.insert 0 'self'
    @pushfunc' async body a *: xs

  #: Evaluate a block while catching all exceptions, then evaluate another block
  #: with either the result of the first one or the exception state.
  #:
  #:   * `try` must push a single item onto the stack, then `else` must push `None` or terminate;
  #:   * on entry to `catch`, the stack is either [..., result, None] or [..., traceback, exception, type];
  #:   * if `catch` calls `rethrow` in this state (must be done once), it is left with [..., result].
  #:   * otherwise, it must push the new result, then call `ignore`.
  #:
  handle_exceptions = try catch else: None opcode: 'SETUP_EXCEPT' ~>
    # SETUP_EXCEPT has somewhat weird behavior in that popping the block also restores
    # the contents of the stack, so we can't just keep items below the current level.
    slot = @varnames !! '<except-result>'
    stacksize = @currstack
    # SETUP_EXCEPT pushes 6 elements when jumping to the handler: old and new contents of `sys.exc_info`.
    with @jump opcode delta: +6 =>
      try!
      @append 'STORE_FAST'  slot delta: -1
      @append 'POP_BLOCK'
      @append 'LOAD_FAST'   slot delta: +1
      @append 'DELETE_FAST' slot
      if else => else!
         otherwise => @pushconst None
    catch
      ->
        has_result = @currstack > stacksize + 1
        has_result => @append 'STORE_FAST'  slot delta: -1  # ugh
        with @jump 'POP_JUMP_IF_FALSE' => # new type
          @append 'POP_TOP' # new value
          @append 'POP_TOP' # new traceback
          @append 'POP_EXCEPT' # restores old type, value, and traceback
        has_result => @append 'LOAD_FAST'   slot delta: +1
        has_result => @append 'DELETE_FAST' slot
      -> @append 'END_FINALLY' delta: -7 # 6 from the setup, 1 from after_try's None

  #: Push the result of `except` onto the stack.
  #:
  #: If any condition matched, the assigned action is evaluated and its value returned. If not,
  #: but no exception was raised, the value of `try` is returned instead. (`name` is where the
  #: exception [or None] is stored.)
  #:
  #: pushexcept :: Node Node [(Node, Node)] -> a
  #:
  pushexcept = name try cases finally ~> if
    finally => @handle_exceptions (-> @pushexcept name try cases None) opcode: 'SETUP_FINALLY' $ ignore rethrow ->
      @loops.append None  # `break` and `continue` should not be used in `finally`.
      @pushnone finally
      @loops.pop -1
      rethrow!
    cases => @handle_exceptions (-> @pushast try) $ ignore rethrow ->
      @append 'DUP_TOP' delta: +1
      with @jump 'JUMP_IF_FALSE_OR_POP' delta: -1 =>
        @append 'DUP_TOP_TWO' delta: +2
        @append 'POP_TOP'     delta: -1
      @popast name
      jumps = list
        where for (cond, action) in cases =>
          @pushcond cond
          with @jump 'POP_JUMP_IF_FALSE' delta: -1 =>
            @pushast action
            ignore! # Done *after* `action` so that `sys.exc_info` behaves correctly.
            yield @jump 'JUMP_FORWARD' delta: -1
      rethrow!
      for j in jumps => j.set
      # Exceptions reference tracebacks which reference frames which reference local
      # variables which an exception is, causing a reference loop that defers all destructors
      # until the next GC sweep. We're going to break that loop.
      name :: Name and name.value in @varnames => @unsafe.add (name.value, @varnames !! name.value)
    otherwise => @pushast try

  #: `await` on the value on top of the stack.
  #:
  #: Possible opcodes:
  #:   GET_AITER      --  calls __aiter__
  #:   GET_ANEXT      --  calls __anext__
  #:   GET_AWAITABLE  --  calls __await__
  #:
  #: On CPython < 3.4, all of these are simulated.
  #:   GET_AITER     = GET_ITER
  #:   GET_ANEXT     = GET_NEXT
  #:   GET_AWAITABLE = GET_ITER
  #:
  #: The second argument is what should be marked as a syntax error if this
  #: code object isn't a coroutine.
  #:
  #: awaittop :: str Node -> a
  #:
  awaittop = opcode errnode delta: 0 ~>
    @generator => raise errnode.invalid 'cannot use `async`/`await` in a generator'
    @coroutine = True
    @append delta: delta $ if
      _PY_FEATURE_ASYNC     => opcode
      opcode == 'GET_ANEXT' => 'GET_NEXT'
      otherwise             => 'GET_ITER'
    @pushconst None
    @append 'YIELD_FROM'

  #: Parse some text as dg code and evaluate in the current context.
  #: Variable names that start with `_` are private and are only defined within
  #: the invocation of the macro itself. Arguments should be ASTs; they are placed
  #: where references to their names would be.
  #:
  #: pushmacro :: Node **Node -> a
  #:
  pushmacro = body **: args ~>
    ast = parse body '<compiler macro>'
    uniq = @counter += 1
    queue = collections.deque [ast]
    while queue =>
      it = queue.popleft!
      if it :: Name and it.value in args => it.__class__, it.__dict__ = (args !! it.value).__class__, (args !! it.value).__dict__
         it :: Name and it.value.startswith '_' => it.value = '<{}:{}>'.format uniq it.value
         it :: Expression =>
            queue.append it.op
            queue.extend it.args
    @pushast ast

  #: Push an `if` condition onto the stack.
  #:
  #: This is the same thing as `pushast`, except if the condition is an assignment
  #: that unpacks an iterable, errors during unpacking are treated as `False`,
  #: while a successful unpacking is True (even if the iterable is empty.)
  #:
  #: pushcond :: Node -> a
  #:
  pushcond = x ~> if
    x :: Expression and x.op == '=' and x.op.infix and not (head x.args :: Name) =>
      x, y = x.args
      @pushmacro '''
        _packed = y
        except
          _error =>
            x = _packed
            True
          _error :: (ValueError, TypeError) => False''' x: x y: y
    otherwise => @pushast x

  #: Pop a value off the stack and store it somewhere.
  #:
  #: popast :: Node -> a
  #:
  popast = x ~> if
    x == '_' => @append 'POP_TOP' delta: -1
    x :: Name => @popname $ if
      x == '@'  => 'self'
      x == '@@' => raise x.invalid 'cannot change superclass'
      otherwise => x.value

    x :: LeftBind => if
      x.op == ',' =>
        @append 'UNPACK_SEQUENCE' 1
        @popast $ fst x.args
      otherwise => raise x.invalid 'not something one can assign to'

    x :: RightBind => if
      # `@@x` returns `super!.x` => `@@x = y` is invalid
      # `@x`  returns `self.x`   => `@x = y` is `self.x = y`
      x.op == '@@' => raise x.invalid 'cannot modify attributes of superclass'
      x.op == '@'  =>
        attr, = x.args
        attr :: Name or raise attr.invalid 'not an attribute'
        @pushname 'self'
        @append   'STORE_ATTR' delta: -2 $ @names !! attr.value

      # A single item prefixed with a star.
      # In a comma-separated list, that is an instruction to put excess
      # items in this variable as a list. When there are no other elements,
      # however, the star does nothing.
      x.op == '*' => @popast $ head x.args
      otherwise   => raise x.invalid 'not something one can assign to'

    x :: Expression => if
      # `x:y = z` or `(x = y) = z` => `x = y = z`
      # The former notation is deprecated.
      x.op == ':' or x.op == '=' =>
        @append 'DUP_TOP' delta: 1
        @popast $ fst x.args
        @popast $ snd x.args

      # A comma-separated list of assignment targets.
      #   1. Assume the value on top of the stack is an iterable.
      #   2. Split it into separate items.
      #   3. Store each of them in an assignment target from this list.
      # Some objects joined with an infix `list'` is what `[a, b, c, ...]` compiles to;
      # we'll handle that as well.
      x.op == ',' or x.op == "list'" =>
        sz = len x.args
        qs = list (where for (i, q) in enumerate x.args =>
          if q :: RightBind and q.op == '*' => yield i)

        if len qs > 1 => raise (x.args !! (qs !! 1)).invalid 'cannot unpack into more than 1 list'
           len qs < 1 => @append delta: (sz - 1) 'UNPACK_SEQUENCE' sz
           otherwise  => @append delta: (sz - 1) 'UNPACK_EX' $ i + 256 * (sz - i - 1) where
             i = head qs
        for a in x.args => @popast a

      x.op == '.' =>
        item, attr = x.args
        attr :: Name or raise attr.invalid 'not an attribute'
        @pushast item
        @append  'STORE_ATTR' delta: -2 $ @names !! attr.value

      x.op == '!!' =>
        @pushast *: x.args
        @append   'STORE_SUBSCR' delta: -3
      otherwise => raise x.invalid 'not something one can assign to'
    otherwise => raise x.invalid 'not something one can assign to'

  #: Push something, then store it somewhere.
  #:
  #: pushpop :: Node Node -> a
  #:
  pushpop = name value ~>
    @var, x = repr name, @var
    @pushast value
    @var = x
    @append 'DUP_TOP' delta: +1
    @popast name

  #: Generate a loop that can use `break` and `continue`. The return value is a boolean
  #: that is true if no `break` was hit.
  #:
  #: loop :: (-> a) (Jump -> b) -> c
  #:
  loop = setup body ~>
    stack_on_entry = @currstack
    @pushconst False
    setup!
    stack_on_body = @currstack
    jmp_head = @jump 'JUMP_ABSOLUTE' True
    jmp_tail = []
    @loops.append (stack_on_entry + 1, stack_on_body, jmp_head, jmp_tail)
    body jmp_head
    @loops.pop -1
    @unwind stack_on_entry
    @pushconst True
    for jmp in jmp_tail => jmp.set

  #: Remove items from the stack until the given size is reached, return the amount popped.
  #:
  #: unwind :: int -> int
  #:
  unwind = size ~> (max @currstack size - size) where
    while @currstack > size => @append 'POP_TOP' delta: -1

  #: Given an AST, find out which local variables it creates.
  #:
  #: symbols :: Node... -> iter str
  #:
  symbols = *: xs ~> for x in xs =>
    # Only expressions may create variables.
    x :: Expression => yield from $ if
      # Compile-time macros may override symbol scans in a way similar to using `prefix`.
      x.op :: Name and (fn = @symscan.get x.op.value) => fn self x.op x.args
      # Default behavior is to push the function, then push the arguments, so we scan them.
      otherwise => @symbols x.op *: x.args

  #: Symbol scanner for `popast`. Returns an iterator of modified variables.
  #:
  #: symbols' :: Node... -> iter str
  #:
  symbols' = *: xs ~> for x in xs => if
    x :: Expression => if
      x.op in (',', '*', ':', "list'") => yield from $ @symbols' *: x.args
      # Assignments to anything else do not create new variables.
      otherwise => yield from $ @symbols x
    x :: Name => if
      x == '@'  => yield 'self'
      otherwise => yield x.value

  #: Ensure an AST can have access to all local variables it needs.
  #:
  #: regsyms :: Node -> a
  #:
  regsyms = x ~> for n in @symbols x => @varnames !! n

  symscan = dict'
    '', f args ~> @symbols $ Expression f.loc *: args
    '->',    _ _ ~> ()  # These operators create new functions, with brand new
    '~>',    _ _ ~> ()  # local namespaces. They will call `symbols` on their own.
    '->>',   _ _ ~> ()
    '~>>',   _ _ ~> ()
    'where', _ _ ~> ()

    '=', fix 2 2 $ f (n, x) ~>
      yield from $ @symbols' n
      yield from $ @symbols  x

    'for', fix 1 2 $ f (var, *body) ~>
      not $ var :: Expression and var.op == 'in' and len var.args == 2 => raise var.invalid $ if
        # In Python, `in` has a higher precedence than `,`. That is,
        # if you simply write `a, b in c` you get `a, (b in c)`. `for a, b in c:`
        # is merely a special case in the parser; dg has no such thing.
        var :: Expression and var.op == ',' and not var.closed => 'forgot the parentheses?'
        otherwise => 'should be `for a in b => ...`'
      v, e = var.args
      yield from $ @symbols' v
      yield from $ @symbols  e *: body

    'except', fix 1 inf $ pair_args $ f ((e, x), *y) ~>
      yield from $ @symbols' e
      yield from $ @symbols  x
      for t in y => yield from $ @symbols *: t

    'import', fix 1 inf $ f (name, *flags) ~>
      qual  = False
      pure  = False
      const = name :: Constant and name.value :: str

      for flag in flags => if
        flag == 'qualified' => qual = True
        flag == 'pure'      => pure = True
        otherwise => raise flag.invalid 'unsupported import modifier'

      f._impdata = const, qual, pure, if
        not const => yield from @symbols name
        otherwise =>
          parent, h, t = except
            err => (BUILTINS !! '!importname') name.value
            err :: ImportError => raise name.invalid $ str err

          t and last t == '*' => if
            pure  => raise name.invalid 'star imports are always impure'
            qual  => raise name.invalid 'star imports are always unqualified'
            @cell => raise name.invalid 'star imports can only appear at global level'

          var = if qual or not t => h
                   otherwise     => last t
          yield var
          parent, [h] + t, var

  #: Built-in functions of any arity.
  prefix = dict'
    '',    f xs ~> @pushcall *: xs
    '\n',  f xs ~> @pushlast *: xs
    '=',   fix 2 2 $ f (name, value) ~> @pushpop name value
    ':=',  fix 2 2 $ f (name, value) ~> @pushpop name value
    '->',  fix 2 2 $ f (args, body)  ~> @pushfunc   f.async args body
    '~>',  fix 2 2 $ f (args, body)  ~> @pushmethod f.async args body
    '->>', fix 2 2 $ f (args, body)  ~> @pushfunc   True    args body
    '~>>', fix 2 2 $ f (args, body)  ~> @pushmethod True    args body

    ':',      undefined 'keyword argument to what function?'
    '!',      undefined 'this operator is postfix'
    '~',      undefined 'this operator is prefix'
    '@',      undefined 'this operator is prefix'
    '@@',     undefined 'this operator is prefix'
    # XXX Python 3.5 allows packing multiple lists into one.
    #     For example, [a_1, a_2, ..., *xs_1, b_1, ..., *xs_2, ...]
    #     first pushes [a_1, a_2, ...], then xs_1, then [b_1, ...], then xs_2, etc.,
    #     before finally joining them with BUILD_LIST_UNPACK(no_of_lists).
    #     Same with tuples (BUILD_TUPLE_UNPACK) and dicts (BUILD_MAP_UNPACK).
    ',',      apply_one 'BUILD_TUPLE'
    "set'",   apply_one 'BUILD_SET'
    "list'",  apply_one 'BUILD_LIST'
    "tuple'", apply_one 'BUILD_TUPLE'
    'or',     shortcircuit 'JUMP_IF_TRUE_OR_POP'
    '=>',     shortcircuit 'JUMP_IF_FALSE_OR_POP'
    'and',    shortcircuit 'JUMP_IF_FALSE_OR_POP'
    'not',    fix 1 1 $ apply_one 'UNARY_NOT'
    '!!',     fix 2 2 $ apply_one 'BINARY_SUBSCR'
    '+',      fix 2 2 $ apply_one 'BINARY_ADD'
    '-',      fix 2 2 $ apply_one 'BINARY_SUBTRACT'
    '*',      fix 2 2 $ apply_one 'BINARY_MULTIPLY'
    '**',     fix 2 2 $ apply_one 'BINARY_POWER'
    '/',      fix 2 2 $ apply_one 'BINARY_TRUE_DIVIDE'
    '//',     fix 2 2 $ apply_one 'BINARY_FLOOR_DIVIDE'
    '%',      fix 2 2 $ apply_one 'BINARY_MODULO'
    '&',      fix 2 2 $ apply_one 'BINARY_AND'
    '^',      fix 2 2 $ apply_one 'BINARY_XOR'
    '|',      fix 2 2 $ apply_one 'BINARY_OR'
    '<<',     fix 2 2 $ apply_one 'BINARY_LSHIFT'
    '>>',     fix 2 2 $ apply_one 'BINARY_RSHIFT'
    '!!=',    fix 2 2 $ inplace $ apply_one 'BINARY_SUBSCR'
    '+=',     fix 2 2 $ inplace $ apply_one 'INPLACE_ADD'
    '-=',     fix 2 2 $ inplace $ apply_one 'INPLACE_SUBTRACT'
    '*=',     fix 2 2 $ inplace $ apply_one 'INPLACE_MULTIPLY'
    '**=',    fix 2 2 $ inplace $ apply_one 'INPLACE_POWER'
    '/=',     fix 2 2 $ inplace $ apply_one 'INPLACE_TRUE_DIVIDE'
    '//=',    fix 2 2 $ inplace $ apply_one 'INPLACE_FLOOR_DIVIDE'
    '%=',     fix 2 2 $ inplace $ apply_one 'INPLACE_MODULO'
    '&=',     fix 2 2 $ inplace $ apply_one 'INPLACE_AND'
    '^=',     fix 2 2 $ inplace $ apply_one 'INPLACE_XOR'
    '|=',     fix 2 2 $ inplace $ apply_one 'INPLACE_OR'
    '<<=',    fix 2 2 $ inplace $ apply_one 'INPLACE_LSHIFT'
    '>>=',    fix 2 2 $ inplace $ apply_one 'INPLACE_RSHIFT'
    'is',     compare
    'in',     compare
    '<',      compare
    '<=',     compare
    '==',     compare
    '!=',     compare
    '>=',     compare
    '>',      compare

    '!!~', fix 2 2 $ f (coll, item)  ~>
      @pushast   coll
      @pushast   item
      @append    'DELETE_SUBSCR' delta: -2
      @pushconst None

    #: Get an attribute of an object by name.
    '.', fix 2 2 $ f (x, y) ~>
      y :: Name or raise y.invalid 'not an attribute'
      @pushast x
      @append  'LOAD_ATTR' $ @names !! y.value

    #: Right pipe into attribute getter: `a |>.b` <=> `(a).b`
    '|>.', fix 2 2 $ f (x, y) ~>
      y :: Name or raise y.invalid 'not an attribute'
      @pushast x
      @append  'LOAD_ATTR' $ @names !! y.value

    #: Call and take an attribute of the result: `a!.b` <=> `(a!).b`
    '!.', fix 2 2 $ f (x, y) ~>
      y :: Name or raise y.invalid 'not an attribute'
      @pushcall x
      @append   'LOAD_ATTR' $ @names !! y.value

    #: Delete an attribute of an object by name.
    '.~', fix 2 2 $ f (x, y) ~>
      y :: Name or raise y.invalid 'not an attribute'
      @pushast   x
      @append    'DELETE_ATTR' delta: -1 $ @names !! y.value
      @pushconst None

    #: Haskell-style left pipe: `a $ b` <=> `a (b)`.
    '$', fix 2 2 $ f (g, x) ~>
      x.closed = True
      if g :: Expression and not g.closed and g.op == '' => @pushcall g.op *: (g.args+:x)
         otherwise => @pushcall g x

    #: Left pipe: `a <| b` <=> `a (b)`.
    '<|', fix 2 2 $ f (g, x) ~>
      x.closed = True
      if g :: Expression and not g.closed and g.op == '' => @pushcall g.op *: (g.args+:x)
         otherwise => @pushcall g x

    #: Right pipe: `a |> b` <=> `b (a)`.
    '|>', fix 2 2 $ f (x, g) ~>
      x.closed = True
      if g :: Expression and not g.closed and g.op == '' => @pushcall g.op *: (g.args+:x)
         otherwise => @pushcall g x

    #: Import a module given a POSIX-style path.
    #:
    #: import '/sys'                 imports a module named 'sys'
    #: import '/os/path' qualified   imports a module named 'os' with a submodule 'path'
    #: import '/dg/addon/fork'       imports 'fork' from package 'dg.addon'
    #: import 'markup'               imports 'markup' from the current package
    #: import '../smth' pure         imports 'smth' from the parent package, returns it
    #:                               but does not create a variable
    #:
    'import', fix 1 inf $ f (name, *flags) ~>
      const, qual, pure, parsed = f._impdata

      if
        not const =>
          not pure => raise name.invalid 'side-effecting imports should be constant'
          @pushname  '!import'
          @pushname  '!importname'
          @pushast   name
          @append    'CALL_FUNCTION' 1 delta: -1
          @pushname  '__package__'
          @pushconst qual
          @append    'CALL_FUNCTION' 3 delta: -3

        qual or (parsed !! 0 == 0 and len (parsed !! 1) == 1) =>
          @pushconst $ parsed !! 0
          @pushconst None
          @append    'IMPORT_NAME' delta: -1 $ @names !! '.'.join (parsed !! 1)

        otherwise =>
          *dir, file = parsed !! 1
          @pushconst $ parsed !! 0
          @pushconst (file,)
          @append    'IMPORT_NAME' delta: -1 $ @names !! '.'.join dir
          if
            file == '*' =>
              pure = True
              @append 'DUP_TOP'     delta:  1  # have to return *something*,
              @append 'IMPORT_STAR' delta: -1  # might as well be the module itself.
            otherwise =>
              @append 'IMPORT_FROM' delta:  1 $ @names !! file
              @append 'ROT_TWO'     delta:  0
              @append 'POP_TOP'     delta: -1

      not pure =>
        @append 'DUP_TOP' delta: +1
        @popname $ parsed !! 2

    #: Local binding.
    #:
    #: I.e. `a where b` makes stuff from `b` only visible in `a`.
    #:
    'where', fix 2 2 $ f (ret, env) ~>
      g = @spawn '<where>' doc: @docstr
      g.coroutine = f.async
      g.regsyms  env
      g.regsyms  ret
      g.pushlast env ret
      @pushclosure g () {}
      @append 'CALL_FUNCTION' 0

    #: Duplicate the local namespace and turn it into a class.
    #:
    #: Tip: `where` is useful here.
    #:
    'subclass', f args ~>
      @pushname  '!subclass'
      @pushname  '!locals'
      @append    'CALL_FUNCTION' 0
      @pushconst @docstring
      @pushconst @qualname
      @pushconst @name
      @pushname  '__name__'
      @pushcalltop 5 args
      # `super` uses this hidden cell variable to determine which class to look at.
      @append 'DUP_TOP' delta: +1
      @append 'STORE_DEREF' (@cellvars !! '__class__') delta: -1

    #: Mark an operation as async.
    #:
    #: This is only supported by a few objects. `for` loops, `with` contexts,
    #: `where` clauses and new functions can be async.
    #:
    'async', autocall $ f [x] ~> if
      x :: Expression and x.op :: Name and @getinternal x.op.value in @asyncs =>
        x.op.async = True
        @pushast x
      otherwise =>
        raise f.invalid 'this cannot be async'

    #: Await until an async operation is complete.
    'await', autocall $ f [x] ~>
      @pushast x
      @awaittop 'GET_AWAITABLE' f

    #: Make the current function terminate early with a value. Only a single
    #: value (which may be a tuple); `return f args` is `return (f args)`.
    'return', autocall $ f [x] ~>
      @pushast x
      @return_top

    #: Throw an exception. Like `return`, `raise f args` <=> `raise $ f args`.
    'raise', autocall $ apply_one 'RAISE_VARARGS'  # TODO __cause__

    #: Call __enter__ at the beginning and __exit__ at the end.
    #:
    #: Using an assignment as the context has special behavior: the assigned
    #: value is the result of __enter__, not the context itself.
    #:
    'with', fix 2 2 $ f (ctx, body) ~>
      var, ctx = if
        ctx :: Expression and len ctx.args == 2 and ctx.op == '=' => ctx.args
        otherwise => Name ctx.loc False '_', ctx

      opcode = 'SETUP_WITH'
      @append 'BUILD_LIST' 0 delta: +1
      @pushast ctx

      f.async => if
        # XXX CPython 3.5: `async with`
        _PY_FEATURE_ASYNC =>
          @append 'BEFORE_ASYNC_WITH'  # `delta` accounted for by 'SETUP_WITH'
          @awaittop 'GET_AWAITABLE' f
          opcode = 'SETUP_ASYNC_WITH'
        # XXX CPython 3.4: simulate as `with var = yield from ctx => body`
        otherwise => @awaittop 'GET_AWAITABLE' f

      with @jump opcode delta: +5 =>  # pops context, pushes __exit__ and returned value
        @popast var
        @pushast body
        @append 'LIST_APPEND' 2 delta: -1
        @append 'POP_BLOCK'
        @pushconst None  # this is for END_FINALLY
      if # XXX CPython 3.4: `__exit__` always synchronous.
         _PY_FEATURE_ASYNC =>
           @append 'WITH_CLEANUP_START'
           f.async => @awaittop 'GET_AWAITABLE' f
           @append 'WITH_CLEANUP_FINISH' delta: -1
         otherwise =>
           @append 'WITH_CLEANUP' delta: -1
      @append 'END_FINALLY' delta: -5
      @append 'UNPACK_SEQUENCE' 1

    #: Repeat while a condition is true.
    #:
    #:   while not done => do something
    #:
    'while', fix 2 2 $ f (cond, body) ~>
      @loop (-> None) $ restart ->
        @pushast cond
        with @jump 'POP_JUMP_IF_FALSE' delta: -1 =>
          @pushnone body
          restart.set

    #: Iterate over something. Something may be asynchronous.
    #:
    #: Note that `var` may be any valid assignment target, not only a local variable.
    #:
    'for', fix 2 2 $ f (var, body) ~>
      f.async =>
        # TODO find a way to implement this in 3.4.
        _PY_FEATURE_ASYNC or raise f.invalid 'no single asynchronous iteration convention in Python < 3.5'
      # `var` was already syntax-checked in `symbols`.
      @loop
        ->
          @pushast $ snd var.args
          if f.async and _PY_FEATURE_SYNC_AITER => @append 'GET_AITER'
             f.async => @awaittop 'GET_AITER' f
             otherwise => @append 'GET_ITER'
        restart -> if
          f.async => @handle_exceptions (-> @awaittop 'GET_ANEXT' f delta: +1)
            ignore rethrow ->
              @append 'DUP_TOP'     delta: +1
              @append 'LOAD_GLOBAL' delta: +1 $ @names !! 'StopAsyncIteration'
              @append 'COMPARE_OP'  delta: -1 $ opcode.cmp_op.index 'exception match'
              with @jump 'POP_JUMP_IF_TRUE' delta: -1 => rethrow! # always terminates
              ignore! # Do not restart the loop, obviously.
            ->
              @popast $ fst var.args
              @pushnone body
              restart.set
          otherwise =>
            with @jump 'FOR_ITER' delta: +1 =>
              @popast $ fst var.args
              @pushnone body
              restart.set
            @currstack -= 1 # `FOR_ITER` pops the iterator when it hits the end

    #: Stop the loop immediately. The loop will return `False`.
    #:
    #:   xs_is_empty = for x in xs => break!
    #:
    'break', fix 0 0 $ f _ ~> if
      last @loops =>
        (stack_on_exit, _, _, jmp_tail) = last @loops
        jmp_tail.append $ @jump 'JUMP_FORWARD' delta: (@unwind stack_on_exit + 1)
      otherwise => raise f.invalid 'no loop to `break` out of'

    #: Continue on to the next iteration.
    #:
    #:   for x in xs => continue!
    #:
    'continue', fix 0 0 $ f _ ~> if
      last @loops =>
        (_, stack_on_body, jmp_head, _) = last @loops
        jmp_head.set_copy delta: (@unwind stack_on_body + 1)
      otherwise => raise f.invalid 'no loop to `continue`'

    #: Yield control to the caller. Enforces a generator context.
    #:
    #:   yield x
    #:   yield f a b c
    #:   yield from x  # `x` must be another generator
    #:   yield from f a b c
    #:
    'yield', fix 1 inf $ f xs ~>
      xs = list xs
      from = head xs == 'from' and not (head xs).closed
      from => xs.pop 0

      @coroutine => raise f.invalid 'cannot use `yield` in a coroutine; use `await` instead'
      @generator = True
      if len xs == 1 => @pushast $ head xs
         otherwise   => @pushcall *: xs
      if from      => @append 'GET_ITER', @pushconst None, @append 'YIELD_FROM' delta: -1
         otherwise => @append 'YIELD_VALUE'

    #: Conditional branching.
    #:
    #:   if
    #:     condition1 => action1  # only one of these is executed
    #:     condition2 => action2
    #:     ...
    #:
    'if', pair_args $ f xs ~>
      jumps = list
        where for (cond, action) in xs =>
          @pushcond cond
          yield with @jump 'POP_JUMP_IF_FALSE' delta: -1 =>
            @pushast action
            @jump 'JUMP_FORWARD' delta: -1
      @pushconst None
      for x in jumps => x.set

    #: Catch exceptions, handle some, rethrow others.
    #:
    #:   except
    #:     var => unsafe code
    #:     condition1 => action1  # exception, if it occurred, was handled
    #:     condition2 => action2
    #:     ...
    #:     finally => something  # will be executed even if exception is going to be rethrown
    #:
    'except', fix 1 inf $ pair_args $ f [(name, try), *xs] ~>
      if xs and head (last xs) == 'finally' => @pushexcept name try xs $ snd $ xs.pop -1
         otherwise                          => @pushexcept name try xs None

  #: Compiler-defined functions that can be wrapped in an `async`.
  #: Attempting to call `async` with anything else is a syntax error.
  asyncs = set $ map (prefix !!) ['->', '~>', 'for', 'with', 'where']

  #: Left infix bind overrides. Unless infix operator `R` is redefined,
  #: these handlers process expressions of kind `x R`.
  infixl = dict'
    '!',     f xs ~> @pushcall *: xs
    ',',     apply_one 'BUILD_TUPLE'
    ':',     undefined 'keyword argument to what function?'
    '~',     undefined 'this operator is prefix'
    '@',     undefined 'this operator is prefix'
    '@@',    undefined 'this operator is prefix'
    '->',    default_to_none
    '~>',    default_to_none
    '->>',   default_to_none
    '~>>',   default_to_none
    'for',   default_to_none
    'while', default_to_none
    'where', default_to_none

  #: Right infix bind overrides. Unless infix operator `R` is redefined,
  #: these handlers process expressions that look like `R x`.
  infixr = dict'
    '~',     apply_one 'UNARY_INVERT'
    '-',     apply_one 'UNARY_NEGATIVE'
    ':',     undefined 'keyword argument to what function?'
    '!',     undefined 'this operator is postfix'
    ',',     undefined 'this operator is unbindable'
    'where', default_to_none

    #: Retrieve an attribute of current instance.
    #:
    #:   @x   <=> self.x
    #:
    '@', f [x] ~>
      x :: Name or raise x.invalid 'not an attribute'
      @pushname 'self'
      @append 'LOAD_ATTR' $ @names !! x.value

    #: Retrieve an attribute of superclass bound to current instance.
    #:
    #:   @@x    <=>    super!.x
    #:
    '@@', f [x] ~>
      x :: Name or raise x.invalid 'not an attribute'
      @pushname '!super'
      @append 'CALL_FUNCTION' 0
      @append 'LOAD_ATTR' $ @names !! x.value

    #: Construct a function with no arguments.
    #:
    #:   -> x
    #:   ->> x   <=>   async $ -> x
    #:
    '->',  f [body] ~> @pushfunc' f.async body () () () {} () () {}
    '->>', f [body] ~> @pushfunc' True    body () () () {} () () {}

    #: Construct a property.
    #:
    #:   ~> x
    #:   ~>> x   <=>   async $ ~> x
    #:
    '~>', f [body] ~>
      @pushname 'property'
      @pushfunc' f.async body ('self',) () () {} () () {}
      @append 'CALL_FUNCTION' 1 delta: -1
    '~>>', f [body] ~>
      @pushname 'property'
      @pushfunc' True    body ('self',) () () {} () () {}
      @append 'CALL_FUNCTION' 1 delta: -1
